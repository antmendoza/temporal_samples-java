package io.twilio;

import com.twilio.taskrunner.protocol.TaskCreationResponse;
import com.twilio.taskrunner.protocol.TaskPayload;
import com.twilio.taskrunner.worker.stats.TaskRunnerWorkerStats;
import io.temporal.activity.ActivityOptions;
import io.temporal.common.RetryOptions;
import io.temporal.failure.ApplicationFailure;
import io.temporal.workflow.Workflow;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.*;

public class TaskRunnerWorkflowImpl implements TaskRunnerWorkflow {


    // REVIEW!! The recomendation is to use Workflow.getLogger instead, to prevent the logs from being printed during replay
    private static final Logger LOG = LoggerFactory.getLogger(TaskRunnerWorkflow.class);

    private TaskCreationResponse currentTask = null;

    @Override
    public String launchActivity(TaskCreationResponse task) {
        if (task.getTaskId() == null) {
            TaskRunnerWorkerStats.getInstance().registerFailedTask();
            throw ApplicationFailure.newFailure("Invalid task received", "No action");
        }
        try {
            this.currentTask = task;
            LOG.info("Starting activity " + task.getTaskId());

            // We're creating the activity here due to the need of getting the retries
            RetryOptions retryOptions = RetryOptions.newBuilder().setInitialInterval(Duration.ofMinutes(3))
                    .setBackoffCoefficient(2)
                    .setMaximumInterval(Duration.ofMinutes(180))
                    .setMaximumAttempts(task.getRetriesLimit())
                    .build();
            ActivityOptions options = ActivityOptions.newBuilder()
                    .setScheduleToStartTimeout(Duration.ofMinutes(1))
                    //REVIEW!! this will make the activity fail if your workers are overloaded (or down) and the server do not deliver the activity task to the workers
                    .setStartToCloseTimeout(Duration.ofSeconds(task.getTimeLimit()))
                    .setRetryOptions(retryOptions)
                    .build();
            TaskRunnerActivity activity = Workflow.newActivityStub(TaskRunnerActivity.class, options);

            if (task.getDequeueTime() != null) {
                scheduleTask(task);
            }

            TaskResponse response = activity.launchTask(task);
            LOG.info("[" + task.getTaskId() + "] Response: " + response);

            if (response.getStatus() > 300) {
                TaskRunnerWorkerStats.getInstance().registerFailedTask();
            } else {
                TaskRunnerWorkerStats.getInstance().registerSuccessfulTask();
            }

            return response.getResponse();
        }
        catch (NullPointerException e) {
            TaskRunnerWorkerStats.getInstance().registerFailedTask();
            throw ApplicationFailure.newFailure("Failed to create activity. Invalid parameters received", "No action");
        }
    }

    private void scheduleTask(TaskCreationResponse task) {
        // Dequeue time is in UTC time

        // REVIEW!! this will cause a NDE since the value is going to be different during replay,
        // use Workflow.currentTimeMillis() insteand that will return the same value for the first run and during replay
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime start = task.getDequeueTime();

        // Converting all DateTime to millis to compare it correctly given potential timezone difference
        long startTimeMillis = ZonedDateTime.of(start, ZoneOffset.UTC).toInstant().toEpochMilli();

        // REVIEW!!  Maybe you should consider using ISO-8601 format when passing this date as an input getDequeueTime,
        // I think this statement could return a different value depending on the workers location
        long nowTimeMillis = ZonedDateTime.of(now, ZoneId.systemDefault()).toInstant().toEpochMilli();

        // Avoid planning for past times

        ///if the code does not come here
        if (nowTimeMillis < startTimeMillis) {
            long startOffset = startTimeMillis - Workflow.currentTimeMillis();
            LOG.info("Scheduling task " + task.getTaskId() + ". Starts in: " + startOffset + " millis");
            Workflow.sleep(startOffset);
        }
    }

}
